# NovaLang 语法规范（EBNF）

本文档使用扩展巴科斯范式（EBNF）定义 NovaLang 的完整语法。

---

## 符号说明

```
=           定义
|           或
( )         分组
[ ]         可选（0或1次）
{ }         重复（0或多次）
" "         终结符（字面量）
UPPER_CASE  Token（词法单元）
lower_case  非终结符（语法规则）
```

---

## 1. 程序结构

```ebnf
(* 程序入口 *)
program = [ shebang ] [ package_decl ] { import_decl } { declaration } EOF ;

(* Shebang - 仅脚本模式 *)
shebang = "#!" { any_char } NEWLINE ;

(* 包声明 *)
package_decl = "package" qualified_name [ NEWLINE | ";" ] ;

(* 导入声明 *)
import_decl = "import" [ "static" ] qualified_name [ "." "*" | "as" IDENTIFIER ]
              [ NEWLINE | ";" ] ;

(* 限定名 *)
qualified_name = IDENTIFIER { "." IDENTIFIER } ;
```

---

## 2. 声明

```ebnf
(* 声明 *)
declaration = class_decl
            | interface_decl
            | object_decl
            | enum_decl
            | fun_decl
            | property_decl
            | typealias_decl
            ;

(* 类声明 *)
class_decl = { annotation } { modifier } "class" IDENTIFIER
             [ type_params ]
             [ primary_constructor ]
             [ ":" supertype_list ]
             [ class_body ] ;

primary_constructor = "(" [ param_list ] ")" ;

supertype_list = supertype { "," supertype } ;

supertype = type [ "(" [ arg_list ] ")" ] ;

class_body = "{" { class_member } "}" ;

class_member = declaration
             | init_block
             | secondary_constructor
             ;

init_block = "init" block ;

secondary_constructor = "constructor" "(" [ param_list ] ")"
                        [ ":" "this" "(" [ arg_list ] ")" ] block ;

(* 接口声明 *)
interface_decl = { annotation } { modifier } "interface" IDENTIFIER
                 [ type_params ]
                 [ ":" supertype_list ]
                 [ interface_body ] ;

interface_body = "{" { interface_member } "}" ;

interface_member = fun_decl | property_decl ;

(* 对象声明 - 单例 *)
object_decl = { annotation } { modifier } "object" IDENTIFIER
              [ ":" supertype_list ]
              [ class_body ] ;

(* 伴生对象 *)
companion_object = "companion" "object" [ IDENTIFIER ] [ ":" supertype_list ]
                   [ class_body ] ;

(* 枚举声明 *)
enum_decl = { annotation } { modifier } "enum" "class" IDENTIFIER
            [ primary_constructor ]
            [ ":" supertype_list ]
            [ enum_body ] ;

enum_body = "{" enum_entries [ ";" { class_member } ] "}" ;

enum_entries = enum_entry { "," enum_entry } [ "," ] ;

enum_entry = IDENTIFIER [ "(" [ arg_list ] ")" ] [ class_body ] ;

(* 函数声明 *)
fun_decl = { annotation } { modifier } "fun"
           [ type_params ]
           [ receiver_type "." ]
           IDENTIFIER
           "(" [ param_list ] ")"
           [ ":" type ]
           ( block | "=" expression ) ;

receiver_type = type ;

param_list = param { "," param } [ "," ] ;

param = { annotation } [ "vararg" ] IDENTIFIER ":" type [ "=" expression ] ;

(* 属性声明 *)
property_decl = { annotation } { modifier } ( "val" | "var" )
                [ type_params ]
                [ receiver_type "." ]
                ( IDENTIFIER | destructure_pattern )
                [ ":" type ]
                [ "=" expression ]
                [ property_accessors ] ;

property_accessors = getter [ setter ] | setter [ getter ] ;

getter = [ modifier ] "get" [ "(" ")" ] ( "=" expression | block ) ;

setter = [ modifier ] "set" [ "(" param ")" ] ( "=" expression | block ) ;

(* 类型别名 *)
typealias_decl = { modifier } "typealias" IDENTIFIER [ type_params ] "=" type ;
```

---

## 3. 修饰符

```ebnf
modifier = visibility_modifier
         | inheritance_modifier
         | "const"
         | "inline"
         | "crossinline"
         | "reified"
         | "operator"
         | "vararg"
         | "suspend"
         | "override"
         ;

visibility_modifier = "public" | "private" | "protected" | "internal" ;

inheritance_modifier = "abstract" | "sealed" | "open" | "final" ;

annotation = "@" IDENTIFIER [ "(" [ annotation_args ] ")" ] ;

annotation_args = annotation_arg { "," annotation_arg } ;

annotation_arg = [ IDENTIFIER "=" ] expression ;
```

---

## 4. 类型

```ebnf
type = simple_type
     | nullable_type
     | function_type
     | parenthesized_type
     ;

simple_type = qualified_name [ type_args ] ;

nullable_type = type "?" ;

function_type = [ "suspend" ] [ "(" type ")" "." ]
                "(" [ type_list ] ")" "->" type ;

parenthesized_type = "(" type ")" ;

type_list = type { "," type } ;

type_args = "<" type_arg { "," type_arg } ">" ;

type_arg = [ "in" | "out" ] type | "*" ;

type_params = "<" type_param { "," type_param } ">" ;

type_param = [ "in" | "out" ] IDENTIFIER [ ":" type ] ;

type_constraint = "where" type_constraint_item { "," type_constraint_item } ;

type_constraint_item = IDENTIFIER ":" type ;
```

---

## 5. 语句

```ebnf
statement = declaration
          | assignment
          | expression_stmt
          | if_stmt
          | when_stmt
          | for_stmt
          | while_stmt
          | do_while_stmt
          | try_stmt
          | return_stmt
          | break_stmt
          | continue_stmt
          | throw_stmt
          | guard_stmt
          | use_stmt
          | block
          ;

block = "{" { statement } "}" ;

expression_stmt = expression [ NEWLINE | ";" ] ;

(* 赋值 *)
assignment = ( IDENTIFIER | member_access | index_access )
             assign_op expression ;

assign_op = "=" | "+=" | "-=" | "*=" | "/=" | "%="
          | "??=" | "||=" | "&&=" ;

(* if 语句/表达式 *)
if_stmt = "if" "(" condition ")" ( statement | block )
          [ "else" ( statement | block ) ] ;

condition = expression
          | "val" IDENTIFIER "=" expression  (* if-let *)
          ;

(* when 表达式 *)
when_stmt = "when" [ "(" expression ")" ] "{"
            { when_branch }
            [ "else" "->" ( expression | block ) ]
            "}" ;

when_branch = when_condition { "," when_condition } "->" ( expression | block ) ;

when_condition = expression
               | "is" type
               | "!is" type
               | "in" expression
               | "!in" expression
               ;

(* for 循环 *)
for_stmt = "for" "(" ( IDENTIFIER | destructure_pattern )
           "in" expression ")" ( statement | block ) ;

(* while 循环 *)
while_stmt = "while" "(" expression ")" ( statement | block ) ;

(* do-while 循环 *)
do_while_stmt = "do" block "while" "(" expression ")" ;

(* try-catch-finally *)
try_stmt = "try" block
           { catch_clause }
           [ finally_clause ] ;

catch_clause = "catch" "(" IDENTIFIER ":" type ")" block ;

finally_clause = "finally" block ;

(* return *)
return_stmt = "return" [ expression ] ;

(* break/continue *)
break_stmt = "break" [ "@" IDENTIFIER ] ;

continue_stmt = "continue" [ "@" IDENTIFIER ] ;

(* throw *)
throw_stmt = "throw" expression ;

(* guard *)
guard_stmt = "guard" "val" IDENTIFIER "=" expression "else"
             ( block | return_stmt | throw_stmt | break_stmt | continue_stmt ) ;

(* use - 资源管理 *)
use_stmt = "use" "(" use_bindings ")" block ;

use_bindings = use_binding { "," use_binding } ;

use_binding = "val" IDENTIFIER "=" expression ;
```

---

## 6. 表达式

```ebnf
(* 表达式 - 按优先级从低到高 *)
expression = pipeline_expr ;

(* 管道操作符 |> *)
pipeline_expr = disjunction_expr { "|>" disjunction_expr } ;

(* 逻辑或 || *)
disjunction_expr = conjunction_expr { "||" conjunction_expr } ;

(* 逻辑与 && *)
conjunction_expr = equality_expr { "&&" equality_expr } ;

(* 相等性 == != === !== *)
equality_expr = comparison_expr { ( "==" | "!=" | "===" | "!==" ) comparison_expr } ;

(* 比较 < > <= >= - 支持链式 *)
comparison_expr = elvis_expr { comparison_op elvis_expr } ;

comparison_op = "<" | ">" | "<=" | ">=" ;

(* Elvis ?: *)
elvis_expr = infix_expr [ "?:" elvis_expr ] ;

(* 中缀调用和范围 *)
infix_expr = range_expr { IDENTIFIER range_expr } ;

(* 范围 .. ..< *)
range_expr = additive_expr [ ( ".." | "..<" ) additive_expr [ "step" additive_expr ] ] ;

(* 加减 + - *)
additive_expr = multiplicative_expr { ( "+" | "-" ) multiplicative_expr } ;

(* 乘除余 * / % *)
multiplicative_expr = prefix_expr { ( "*" | "/" | "%" ) prefix_expr } ;

(* 前缀操作符 *)
prefix_expr = { prefix_op } postfix_expr ;

prefix_op = "-" | "+" | "!" | "++" | "--" ;

(* 后缀操作符 *)
postfix_expr = primary_expr { postfix_op } ;

postfix_op = "++"
           | "--"
           | "!!"                          (* 非空断言 *)
           | "?"                           (* 错误传播 *)
           | call_suffix
           | index_suffix
           | member_suffix
           | safe_call_suffix
           | lambda_suffix
           ;

call_suffix = [ type_args ] "(" [ arg_list ] ")" ;

index_suffix = "[" ( expression | slice_expr ) "]" ;

slice_expr = [ expression ] ".." [ "<" ] [ expression ] ;

member_suffix = "." IDENTIFIER ;

safe_call_suffix = "?." IDENTIFIER [ call_suffix ]
                 | "?" "[" expression "]"    (* 安全索引 *)
                 | "?" "(" [ arg_list ] ")"  (* 安全调用 *)
                 ;

lambda_suffix = [ type_args ] lambda ;

(* 参数列表 *)
arg_list = arg { "," arg } [ "," ] ;

arg = [ IDENTIFIER "=" ] expression
    | "*" expression  (* spread *)
    ;
```

---

## 7. 基础表达式

```ebnf
primary_expr = literal
             | IDENTIFIER
             | "this" [ "@" IDENTIFIER ]
             | "super" [ "@" IDENTIFIER ]
             | "it"
             | "_"                        (* 占位符 *)
             | parenthesized_expr
             | collection_literal
             | lambda
             | object_literal
             | when_expr
             | if_expr
             | try_expr
             | async_expr
             | jump_expr
             | method_reference
             ;

(* 字面量 *)
literal = INT_LITERAL
        | LONG_LITERAL
        | FLOAT_LITERAL
        | DOUBLE_LITERAL
        | CHAR_LITERAL
        | STRING_LITERAL
        | RAW_STRING_LITERAL
        | MULTILINE_STRING_LITERAL
        | "true"
        | "false"
        | "null"
        ;

(* 括号表达式 *)
parenthesized_expr = "(" expression ")" ;

(* 集合字面量 *)
collection_literal = list_literal
                   | map_literal
                   | set_literal
                   ;

list_literal = "[" [ expression_list ] "]" ;

map_literal = "#" "{" [ map_entry_list ] "}" ;

map_entry_list = map_entry { "," map_entry } [ "," ] ;

map_entry = expression ":" expression ;

set_literal = "#" "{" [ expression_list ] "}" ;

expression_list = expression { "," expression } [ "," ] ;

(* Lambda *)
lambda = "{" [ lambda_params "->" ] { statement } [ expression ] "}" ;

lambda_params = lambda_param { "," lambda_param } ;

lambda_param = [ IDENTIFIER ":" type ] IDENTIFIER | "_" ;

(* 匿名对象 *)
object_literal = "object" [ ":" supertype_list ] class_body ;

(* 表达式形式的 when *)
when_expr = "when" [ "(" expression ")" ] "{"
            { when_branch }
            [ "else" "->" expression ]
            "}" ;

(* 表达式形式的 if *)
if_expr = "if" "(" condition ")" expression "else" expression ;

(* 表达式形式的 try *)
try_expr = "try" block
           { catch_clause }
           [ finally_clause ] ;

(* 异步表达式 *)
async_expr = "async" block ;

await_expr = "await" expression ;

(* 跳转表达式 *)
jump_expr = return_stmt
          | break_stmt
          | continue_stmt
          | throw_stmt
          ;

(* 方法引用 *)
method_reference = [ type | expression ] "::" IDENTIFIER
                 | [ type ] "::" "new"  (* 构造器引用 *)
                 ;

(* 类型检查和转换 *)
type_check = expression ( "is" | "!is" ) type ;

type_cast = expression ( "as" | "as?" ) type ;

(* 包含检查 *)
containment = expression ( "in" | "!in" ) expression ;

(* 解构 *)
destructure_pattern = "(" IDENTIFIER { "," IDENTIFIER } ")" ;
```

---

## 8. 字符串插值

```ebnf
interpolated_string = STRING_START
                      { string_content | interpolation }
                      STRING_END ;

string_content = STRING_CHARS ;

interpolation = "$" IDENTIFIER
              | "${" expression "}"
              ;
```

---

## 9. 操作符优先级表（从低到高）

| 优先级 | 操作符 | 结合性 | 说明 |
|--------|--------|--------|------|
| 1 | `\|>` | 左 | 管道 |
| 2 | `\|\|` | 左 | 逻辑或 |
| 3 | `&&` | 左 | 逻辑与 |
| 4 | `== != === !==` | 左 | 相等性 |
| 5 | `< > <= >=` | 左 | 比较（支持链式） |
| 6 | `?:` | 右 | Elvis |
| 7 | `in !in is !is` | 左 | 包含/类型检查 |
| 8 | `..` `..<` | 左 | 范围 |
| 9 | `+ -` | 左 | 加减 |
| 10 | `* / %` | 左 | 乘除余 |
| 11 | `- + ! ++ --` | 右 | 前缀 |
| 12 | `++ -- !! ? . ?. () [] ::` | 左 | 后缀 |

---

## 10. 示例解析

### 10.1 简单函数
```nova
fun add(a: Int, b: Int): Int = a + b
```
解析为：
```
fun_decl
├── name: "add"
├── params: [param(a, Int), param(b, Int)]
├── return_type: Int
└── body: binary_expr(a, +, b)
```

### 10.2 Lambda 与尾随 Lambda
```nova
list.filter { it > 0 }.map { it * 2 }
```
解析为：
```
call_expr
├── receiver: call_expr
│   ├── receiver: identifier("list")
│   ├── method: "filter"
│   └── args: [lambda(it > 0)]
├── method: "map"
└── args: [lambda(it * 2)]
```

### 10.3 管道表达式
```nova
input |> parse |> filter { it > 0 } |> process(_, config)
```
解析为：
```
pipeline_expr
├── left: pipeline_expr
│   ├── left: pipeline_expr
│   │   ├── left: identifier("input")
│   │   └── right: identifier("parse")
│   └── right: call_expr(filter, [lambda])
└── right: call_expr(process, [placeholder, identifier(config)])
```

---

*NovaLang 语法规范 v1.0*
