# 注解系统

NovaLang 提供可扩展的注解系统，支持内置注解（`@data`、`@builder`）和自定义注解处理器（Java 和 Nova 两种注册方式）。

> **当前状态**：注解系统完整支持解释执行模式。编译器（字节码生成）尚未实现注解处理。

---

## 定义注解

使用 `annotation class` 关键字定义注解类型：

```nova
// 无参注解
annotation class Serializable

// 带参数注解
annotation class JsonName(val name: String)

// 多参数注解
annotation class Range(val min: Int, val max: Int)
```

注解类的限制：
- 不能有类体（大括号内的成员）
- 不能有超类型
- 不能被实例化（`Serializable()` 会报错）

---

## 使用注解

注解可以标注在类、函数、属性上：

```nova
// 标注类
@Serializable
class Config(val host: String, val port: Int)

// 多个注解叠加
@data @builder
class Point(val x: Int, val y: Int)

// 带参数注解
@JsonName(name = "server_config")
class ServerConfig(val host: String)

// 标注函数
@Deprecated
fun oldMethod() = "legacy"

// 标注属性
@Range(min = 0, max = 100)
val score = 85
```

---

## 内置注解

### @data

将类标记为数据类，自动生成：
- `componentN()` 方法 — 按构造参数顺序返回字段值
- `copy()` 方法 — 创建副本，可覆盖部分字段
- 解构赋值支持

```nova
@data class Point(val x: Int, val y: Int)

val p = Point(3, 4)

// componentN
p.component1()  // 3
p.component2()  // 4

// 解构赋值
val (a, b) = p   // a=3, b=4

// copy
val p2 = p.copy(x = 10)  // Point(10, 4)
val p3 = p.copy()         // Point(3, 4)  完整复制
```

### @builder

为类生成 `builder()` 静态方法，支持链式构建：

```nova
@builder class ServerConfig(val host: String, val port: Int)

val config = ServerConfig.builder()
    .host("example.com")
    .port(9090)
    .build()

config.host  // "example.com"
config.port  // 9090
```

链式调用顺序无关：

```nova
val config = ServerConfig.builder()
    .port(8080)
    .host("localhost")
    .build()
```

### 组合使用

`@data` 和 `@builder` 可以叠加：

```nova
@data @builder class Point(val x: Int, val y: Int)

// builder 创建
val p = Point.builder().x(1).y(2).build()

// data 解构
val (a, b) = p  // a=1, b=2
```

---

## 自定义注解处理器

### 方式一：Nova 脚本注册

通过 `registerAnnotationProcessor(name, handler)` 注册处理器。handler 接收两个参数：`target`（被注解的目标）和 `args`（注解参数 Map）。

```nova
// 注册处理器
registerAnnotationProcessor("track") { target, args ->
    println("Tracked: ${target.name}")
}

// 使用
@track class MyService  // 输出: Tracked: MyService
```

带参数的自定义注解：

```nova
registerAnnotationProcessor("tag") { target, args ->
    println("Tag: ${args["value"]}")
}

@tag(value = "important") class Config  // 输出: Tag: important
```

handler 的 `target` 参数类型取决于注解位置：
- 类注解：`target` 为 `ClassInfo`（反射对象，详见[反射 API](反射API.md)）
- 函数注解：`target` 为 `NovaFunction`
- 属性注解：`target` 为属性名（String）

#### 处理器句柄

`registerAnnotationProcessor` 返回一个句柄对象，支持动态注销、重新注册和替换处理器：

```nova
val handle = registerAnnotationProcessor("log") { target, args ->
    println("Logged: " + target.name)
}

// 注销处理器（后续被 @log 注解的类不再触发此处理器）
handle.unregister()

// 重新注册（恢复处理器）
handle.register()

// 替换处理器 handler
handle.replace { target, args ->
    println("New handler: " + target.name)
}
```

句柄方法说明：

| 方法 | 说明 |
|------|------|
| `handle.unregister()` | 从注册表中移除此处理器 |
| `handle.register()` | 将此处理器重新注册到注册表 |
| `handle.replace(newHandler)` | 替换处理器的 handler，不影响注册状态 |

#### 在处理器中使用反射 API

类注解处理器的 `target` 是 `ClassInfo` 对象，可以访问类的字段、方法等元信息：

```nova
registerAnnotationProcessor("validate") { target, args ->
    // target 是 ClassInfo，可访问反射属性
    println("类名: " + target.name)
    println("字段数: " + target.fields.size())

    // 遍历字段
    for (f in target.fields) {
        println("  " + f.name + ": " + f.type + " (mutable=" + f.mutable + ")")
    }

    // 遍历方法
    for (m in target.methods) {
        println("  方法: " + m.name + ", 参数数: " + m.params.size())
    }
}

annotation class validate

@validate class User(val name: String, var age: Int) {
    fun greet() = "Hello, $name"
}
// 输出:
// 类名: User
// 字段数: 2
//   name: String (mutable=false)
//   age: Int (mutable=true)
//   方法: greet, 参数数: 0
```

更多反射 API 用法请参考 [反射 API 文档](反射API.md)。

### 方式二：Java 注册

实现 `NovaAnnotationProcessor` 接口：

```java
import nova.runtime.interpreter.*;
import java.util.Map;

public class DeprecatedProcessor implements NovaAnnotationProcessor {

    @Override
    public String getAnnotationName() {
        return "Deprecated";
    }

    @Override
    public void processClass(NovaClass target, Map<String, NovaValue> args, Interpreter interpreter) {
        // 在类上设置标记
        target.setStaticField("isDeprecated", NovaBoolean.TRUE);
    }

    @Override
    public void processFun(NovaFunction target, Map<String, NovaValue> args, Interpreter interpreter) {
        // 处理函数注解
        System.out.println("Warning: " + target.getName() + " is deprecated");
    }

    @Override
    public void processProperty(String propertyName, NovaValue propertyValue,
                                 Map<String, NovaValue> args, Interpreter interpreter) {
        // 处理属性注解
    }
}
```

注册到解释器：

```java
Interpreter interpreter = new Interpreter();
interpreter.registerAnnotationProcessor(new DeprecatedProcessor());

interpreter.eval("@Deprecated class OldService");
interpreter.eval("OldService.isDeprecated");  // true
```

使用 Nova 便捷 API：

```java
Nova nova = new Nova();
nova.getInterpreter().registerAnnotationProcessor(new DeprecatedProcessor());
nova.eval("@Deprecated class OldService");
```

`NovaAnnotationProcessor` 接口方法均有默认空实现，只需覆盖需要的方法即可。

---

## 运行时查询注解

### 方式一：类名.annotations

通过 `类名.annotations` 查询类上的注解列表，返回 `List<Map>`：

```nova
@data @builder class Point(val x: Int, val y: Int)

val anns = Point.annotations
println(anns.size())  // 2

// 每个注解是一个 Map，包含 name 和 args
val first = anns[0]
println(first["name"])  // "data"
println(first["args"])  // {}

// 带参数的注解
@tag(value = "hello") class Foo
val fooAnns = Foo.annotations
println(fooAnns[0]["name"])           // "tag"
println(fooAnns[0]["args"]["value"])  // "hello"
```

### 方式二：通过反射 API

通过 `classOf()` 获取 `ClassInfo`，其 `annotations` 属性返回 `List<AnnotationInfo>`：

```nova
@data class Point(val x: Int, val y: Int)

val info = classOf(Point)
for (ann in info.annotations) {
    println(ann.name)  // "data"
    println(ann.args)  // {}
}
```

---

## 注解处理器接口参考

```java
public interface NovaAnnotationProcessor {
    /** 返回此处理器关联的注解名称 */
    String getAnnotationName();

    /** 处理类注解（默认空实现） */
    default void processClass(NovaClass target, Map<String, NovaValue> args,
                               Interpreter interpreter) {}

    /** 处理函数注解（默认空实现） */
    default void processFun(NovaFunction target, Map<String, NovaValue> args,
                             Interpreter interpreter) {}

    /** 处理属性注解（默认空实现） */
    default void processProperty(String propertyName, NovaValue propertyValue,
                                  Map<String, NovaValue> args,
                                  Interpreter interpreter) {}
}
```

| 注解位置 | 调用方法 | target 类型 |
|----------|----------|-------------|
| 类 | `processClass` | `NovaClass` |
| 函数 | `processFun` | `NovaFunction` |
| 属性 | `processProperty` | `String`（属性名） |

---

## 注意事项

- 未注册处理器的注解会被静默忽略（不报错），但仍可通过 `.annotations` 查询
- 同一个注解名可以注册多个处理器，全部会被调用
- 注解处理发生在声明执行时（非编译时）
- 编译模式（字节码生成）当前不支持注解处理，`@data`/`@builder` 等注解在编译后不生效
