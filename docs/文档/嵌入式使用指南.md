# 嵌入式使用指南

在 Java 或 Kotlin 项目中嵌入 NovaLang，执行 Nova 脚本、注入变量、注册自定义函数。

提供四种使用方式：
- **Nova 便捷 API**（推荐）— 一行代码执行脚本，零样板代码
- **Interpreter API** — 直接使用解释器，轻量、灵活、完全控制
- **Compiler + Interpreter** — 手动控制编译流程，支持 AST 缓存和复用
- **JSR-223 ScriptEngine** — 标准 `javax.script` 接口，适合需要引擎发现和标准化集成的场景

## 添加依赖

根据使用方式选择依赖模块：

| 使用方式 | 依赖模块 | 说明 |
|----------|----------|------|
| Interpreter API | `nova-runtime` | 直接调用解释器 |
| JSR-223 ScriptEngine | `nova-script` | 标准脚本引擎（自动传递依赖 nova-runtime） |

**Gradle (Groovy DSL):**

```groovy
dependencies {
    // 方式一：仅使用 Interpreter
    implementation 'com.novalang:nova-runtime:0.1.0-SNAPSHOT'

    // 方式二：使用 JSR-223（包含 Interpreter）
    implementation 'com.novalang:nova-script:0.1.0-SNAPSHOT'
}
```

**Gradle (Kotlin DSL):**

```kotlin
dependencies {
    // 方式一
    implementation("com.novalang:nova-runtime:0.1.0-SNAPSHOT")

    // 方式二
    implementation("com.novalang:nova-script:0.1.0-SNAPSHOT")
}
```

**Maven:**

```xml
<!-- 方式一 -->
<dependency>
    <groupId>com.novalang</groupId>
    <artifactId>nova-runtime</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>

<!-- 方式二 -->
<dependency>
    <groupId>com.novalang</groupId>
    <artifactId>nova-script</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
```

> 本地多模块引用可写为 `implementation project(':nova-runtime')` 或 `implementation project(':nova-script')`。

---

## Nova 便捷 API（推荐）

`Nova` 类是最简单的嵌入方式，位于 `nova.runtime` 包，提供静态一行调用和实例共享状态两种模式。

### 静态调用 — 一行执行

```java
import nova.runtime.Nova;

// 执行表达式
Object result = Nova.run("1 + 2");  // 3

// 绑定变量
Object result = Nova.run("x + y", "x", 10, "y", 20);  // 30

// 执行文件
Object result = Nova.runFile("script.nova");
Object result = Nova.runFile("script.nova", "n", 100);
```

每次 `run`/`runFile` 会创建临时实例，适合无状态的单次执行。

### 实例调用 — 共享状态

```java
Nova nova = new Nova();

// 注入变量（fluent API）
nova.set("name", "Alice").set("age", 30);

// 执行代码
nova.eval("fun greet(name: String) = \"Hello, $name!\"");

// 调用函数
Object greeting = nova.call("greet", "World");  // "Hello, World!"

// 读取变量
Object age = nova.get("age");  // 30
```

同一实例的多次 `eval` 共享全局环境，适合需要累积定义和状态的场景。

### 加载文件后调用函数

```java
Nova nova = new Nova();
nova.evalFile("utils.nova");
Object result = nova.call("calculate", 100, 0.15);
```

### 安全策略

```java
import nova.runtime.interpreter.NovaSecurityPolicy;

Nova nova = new Nova(NovaSecurityPolicy.strict());
nova.eval("1 + 2");  // 正常执行
```

### 预编译 — 解析一次，执行多次

`compile()` 预先解析代码为内部表示，返回 `CompiledNova` 对象，之后可反复执行，省去每次解析的开销。典型场景：启动时编译配置文件中的规则，运行时用不同参数多次执行。

```java
// 启动时：编译规则
CompiledNova rule = Nova.compile("price * quantity * (1 - discount)");

// 运行时：多次执行
rule.set("price", 100).set("quantity", 2).set("discount", 0.1);
Object total1 = rule.run();  // 180.0

rule.set("price", 50).set("quantity", 5).set("discount", 0.2);
Object total2 = rule.run();  // 200.0

// 也可以直接在 run 中绑定变量
Object total3 = rule.run("price", 200, "quantity", 1, "discount", 0);  // 200.0
```

从文件预编译：

```java
// 启动时：编译函数库
CompiledNova lib = Nova.compileFile("rules.nova");
lib.run();  // 执行一次，定义函数

// 运行时：调用函数
Object r1 = lib.call("calculate", 100);
Object r2 = lib.call("calculate", 200);
```

需要共享已有环境时，使用实例方法：

```java
Nova nova = new Nova();
nova.eval("val TAX_RATE = 0.08");  // 先定义常量
CompiledNova rule = nova.compile("price * (1 + TAX_RATE)", "tax-rule");
rule.set("price", 100);
rule.run();  // 108.0
```

`CompiledNova` API：

| 方法 | 说明 |
|------|------|
| `run()` | 执行预编译代码 |
| `run(bindings...)` | 绑定变量后执行（key-value 形式） |
| `call(funcName, args...)` | 调用预编译代码中定义的函数 |
| `set(name, value)` | 设置变量，返回 `this`（支持链式调用） |
| `get(name)` | 获取变量值 |
| `getNova()` | 获取关联的 Nova 实例 |

### 完整 API

**静态方法（一行调用）：**

| 方法 | 说明 |
|------|------|
| `Nova.run(code)` | 执行代码 |
| `Nova.run(code, bindings...)` | 执行代码 + 变量绑定 |
| `Nova.runFile(path)` | 执行文件 |
| `Nova.runFile(path, bindings...)` | 执行文件 + 变量绑定 |
| `Nova.compile(code)` | 预编译代码，返回 `CompiledNova` |
| `Nova.compileFile(path)` | 预编译文件，返回 `CompiledNova` |

**实例方法（共享状态）：**

| 方法 | 说明 |
|------|------|
| `new Nova()` | 创建实例（无限制策略） |
| `new Nova(policy)` | 创建实例（指定安全策略） |
| `set(name, value)` | 注入变量，返回 `this`（支持链式调用） |
| `get(name)` | 读取变量，不存在返回 `null` |
| `eval(code)` | 执行代码，返回最后表达式的值 |
| `evalFile(path)` | 执行文件 |
| `evalFile(file)` | 执行文件（`File` 对象） |
| `compile(code, fileName)` | 预编译代码，共享已有环境 |
| `compileFile(file)` | 预编译文件，共享已有环境 |
| `call(funcName, args...)` | 调用已定义的函数 |
| `getInterpreter()` | 获取底层 `Interpreter`（进阶使用） |

> 所有返回值自动从 Nova 类型转换为 Java 类型。`val`/`var` 声明返回赋值结果，`fun` 声明返回 `null`。

---

## 进阶方式

以下三种方式提供更底层的控制，适合有特殊需求的场景。

---

## 方式一：Interpreter API

直接构造 `Interpreter` 实例，无需 SPI 发现，适合对执行过程需要完全控制的场景。

### 基本执行

**Java:**

```java
import nova.runtime.interpreter.Interpreter;

Interpreter interpreter = new Interpreter();

// 执行表达式，返回 NovaValue
Object result = interpreter.eval("1 + 2").toJavaValue();
System.out.println(result);  // 3

// 执行多行脚本
Object sum = interpreter.eval(
    "val x = 10\n" +
    "val y = 20\n" +
    "x + y"
).toJavaValue();
System.out.println(sum);  // 30
```

**Kotlin:**

```kotlin
import nova.runtime.interpreter.Interpreter

val interpreter = Interpreter()

val result = interpreter.eval("""
    val x = 10
    val y = 20
    x + y
""".trimIndent()).toJavaValue()
println(result)  // 30
```

> `eval()` 返回 `NovaValue`，调用 `.toJavaValue()` 转换为 Java 类型。

### 注入和读取变量

通过 `Environment` 在 Java 和 Nova 之间传递数据：

```java
import nova.runtime.interpreter.*;

Interpreter interpreter = new Interpreter();
Environment globals = interpreter.getGlobals();

// 注入变量
globals.defineVar("name", new NovaString("Alice"));
globals.defineVar("score", NovaInt.of(95));

// 执行脚本
interpreter.eval("val greeting = \"Hello, $name! Score: $score\"");

// 读取变量
NovaValue greeting = globals.get("greeting");
System.out.println(greeting.toJavaValue());  // Hello, Alice! Score: 95
```

`Environment` 常用方法：

| 方法 | 说明 |
|------|------|
| `defineVal(name, value)` | 定义不可变变量（val） |
| `defineVar(name, value)` | 定义可变变量（var） |
| `get(name)` | 获取变量值，不存在抛异常 |
| `tryGet(name)` | 获取变量值，不存在返回 null |
| `assign(name, value)` | 修改已存在的可变变量 |
| `contains(name)` | 检查变量是否存在 |

### I/O 重定向

```java
import java.io.*;

Interpreter interpreter = new Interpreter();

// 捕获输出
ByteArrayOutputStream baos = new ByteArrayOutputStream();
interpreter.setStdout(new PrintStream(baos));

interpreter.eval("println(\"hello from nova\")");
System.out.println(baos.toString().trim());  // hello from nova

// 恢复默认
interpreter.setStdout(System.out);
```

| 方法 | 说明 |
|------|------|
| `setStdout(PrintStream)` | 设置标准输出 |
| `setStderr(PrintStream)` | 设置标准错误 |
| `setStdin(InputStream)` | 设置标准输入 |

### 异常处理

```java
import nova.runtime.interpreter.NovaRuntimeException;

try {
    interpreter.eval("error(\"something went wrong\")");
} catch (NovaRuntimeException e) {
    System.err.println(e.getMessage());  // something went wrong
}
```

### 多次执行共享状态

同一个 `Interpreter` 实例的多次 `eval` 共享全局环境：

```java
Interpreter interpreter = new Interpreter();
interpreter.eval("val x = 10");
interpreter.eval("val y = x + 20");
Object result = interpreter.eval("y").toJavaValue();
System.out.println(result);  // 30
```

---

## 方式二：Compiler + Interpreter

手动调用 Lexer、Parser 进行编译，再用 Interpreter 执行 AST。适合需要缓存 AST 反复执行、或需要在编译和执行之间插入自定义处理（优化、检查、转换等）的场景。

### 编译流程

NovaLang 的执行分为三个阶段：

```
源代码 → Lexer(词法分析) → Parser(语法分析) → AST → Interpreter(执行) → 结果
```

`Interpreter.eval(String)` 内部包含了全部三个阶段。手动拆分后可以独立控制每一步。

### 基本用法

```java
import com.novalang.compiler.lexer.Lexer;
import com.novalang.compiler.parser.Parser;
import com.novalang.compiler.ast.AstNode;
import nova.runtime.interpreter.Interpreter;

String source = "val x = 10\nval y = 20\nx + y";

// 1. 词法分析 + 语法分析 → AST
Lexer lexer = new Lexer(source, "script.nova");
Parser parser = new Parser(lexer, "script.nova");

List<AstNode> ast = new ArrayList<>();
AstNode node;
while ((node = parser.parseReplInput()) != null) {
    ast.add(node);
}

// 2. 执行 AST
Interpreter interpreter = new Interpreter();
NovaValue result = interpreter.eval(ast);
System.out.println(result.toJavaValue());  // 30
```

### 缓存 AST 反复执行

解析一次，执行多次，省去重复编译开销：

```java
// 编译一次
String script = "n * n + 1";
Lexer lexer = new Lexer(script, "<cached>");
Parser parser = new Parser(lexer, "<cached>");

List<AstNode> ast = new ArrayList<>();
AstNode node;
while ((node = parser.parseReplInput()) != null) {
    ast.add(node);
}

// 执行多次
Interpreter interpreter = new Interpreter();
Environment globals = interpreter.getGlobals();

globals.defineVar("n", NovaInt.of(3));
System.out.println(interpreter.eval(ast).toJavaValue());  // 10

globals.assign("n", NovaInt.of(7));
System.out.println(interpreter.eval(ast).toJavaValue());  // 50
```

### 完整程序解析（parse）

除了 `parseReplInput()` 逐条解析外，也可以用 `parse()` 一次性解析完整程序（含 package 和 import 声明）：

```java
import com.novalang.compiler.ast.decl.Program;

String source = "fun greet(name: String) = \"Hello, $name!\"\nprintln(greet(\"Nova\"))";

Lexer lexer = new Lexer(source, "app.nova");
Parser parser = new Parser(lexer, "app.nova");
Program program = parser.parse();

Interpreter interpreter = new Interpreter();
interpreter.execute(program);  // Hello, Nova!
```

### Parser 和 Lexer API

**Lexer 构造函数：**

| 构造函数 | 说明 |
|----------|------|
| `Lexer(source)` | 使用默认文件名 `<input>` |
| `Lexer(source, fileName)` | 指定文件名（用于错误报告） |
| `Lexer(source, fileName, errStream)` | 指定文件名和错误输出流 |

**Parser 方法：**

| 方法 | 说明 |
|------|------|
| `Parser(lexer, fileName)` | 构造解析器 |
| `parse()` | 解析完整程序，返回 `Program`（含 package/import/declarations） |
| `parseReplInput()` | 逐条解析顶层声明/语句/表达式，EOF 时返回 `null` |

**Interpreter 执行方法：**

| 方法 | 说明 |
|------|------|
| `eval(String source)` | 解析并执行源代码字符串 |
| `eval(String source, String fileName)` | 指定文件名（用于错误报告） |
| `eval(List<AstNode> nodes)` | 执行预解析的 AST 节点列表 |
| `execute(Program program)` | 执行完整程序 AST |
| `execute(Declaration decl)` | 执行单个声明 |
| `execute(Statement stmt)` | 执行单个语句 |
| `evaluate(Expression expr)` | 求值单个表达式 |

---

## 方式三：JSR-223 ScriptEngine

通过标准 `javax.script` API 使用，支持 `ScriptEngineManager` 自动发现。

### 获取引擎

```java
import javax.script.*;

ScriptEngineManager manager = new ScriptEngineManager();

// 按名称（支持三种写法）
ScriptEngine engine = manager.getEngineByName("nova");
ScriptEngine engine = manager.getEngineByName("novalang");
ScriptEngine engine = manager.getEngineByName("NovaLang");

// 按文件扩展名
ScriptEngine engine = manager.getEngineByExtension("nova");

// 按 MIME 类型
ScriptEngine engine = manager.getEngineByMimeType("application/x-nova");
```

### 执行脚本

```java
// 表达式
Object result = engine.eval("1 + 2");  // 3

// 多行脚本
Object sum = engine.eval(
    "val x = 10\n" +
    "val y = 20\n" +
    "x + y"
);  // 30

// 从 Reader 执行
Object fileResult = engine.eval(new java.io.FileReader("script.nova"));
```

> ScriptEngine 的 `eval()` 直接返回 Java 类型，无需手动调用 `toJavaValue()`。

### 变量绑定（Bindings）

```java
// 注入
engine.put("name", "Alice");
engine.put("scores", Arrays.asList(90, 85, 92));

// 脚本中使用
engine.eval(
    "val avg = scores.reduce(0) { acc, x -> acc + x } / scores.size()\n" +
    "val report = \"$name 的平均分: $avg\""
);

// 回读
System.out.println(engine.get("report"));  // Alice 的平均分: 89
System.out.println(engine.get("avg"));     // 89
```

### 预编译（Compilable）

对反复执行的脚本预编译，跳过重复解析：

```java
Compilable compilable = (Compilable) engine;
CompiledScript compiled = compilable.compile("n * n + 1");

engine.put("n", 3);
System.out.println(compiled.eval());  // 10

engine.put("n", 7);
System.out.println(compiled.eval());  // 50
```

### 输出重定向

```java
StringWriter output = new StringWriter();
engine.getContext().setWriter(output);

engine.eval("println(\"hello from nova\")");
System.out.println(output.toString().trim());  // hello from nova

// 错误输出同理
StringWriter errOutput = new StringWriter();
engine.getContext().setErrorWriter(errOutput);
```

### 异常处理

ScriptEngine 将所有错误统一包装为 `ScriptException`：

```java
try {
    engine.eval("1 / 0");
} catch (ScriptException e) {
    System.err.println("脚本错误: " + e.getMessage());
}
```

### 引擎工厂信息

```java
ScriptEngineFactory factory = engine.getFactory();
factory.getEngineName();       // "NovaLang"
factory.getEngineVersion();    // "0.1.0"
factory.getLanguageName();     // "nova"
factory.getLanguageVersion();  // "0.1.0"
factory.getExtensions();       // ["nova"]
factory.getMimeTypes();        // ["application/x-nova"]
factory.getNames();            // ["nova", "novalang", "NovaLang"]
```

---

## 四种方式对比

| 特性 | Nova 便捷 API | Interpreter API | Compiler + Interpreter | JSR-223 ScriptEngine |
|------|--------------|----------------|----------------------|---------------------|
| 依赖 | `nova-runtime` | `nova-runtime` | `nova-runtime` | `nova-script` |
| 返回值 | 自动转换为 Java 类型 | `NovaValue` | `NovaValue` | 自动转换为 Java 类型 |
| 变量交互 | `set`/`get` | `Environment` | `Environment` | `Bindings`（put/get） |
| 函数调用 | `call()` | 手动操作 | 手动操作 | 不支持 |
| AST 缓存复用 | 不支持 | 不支持 | 支持 | `Compilable.compile()` |
| 编译/执行分离 | 不支持 | 不支持 | 支持 | 不支持 |
| I/O 重定向 | 通过 `getInterpreter()` | `PrintStream` | `PrintStream` | `Writer`（ScriptContext） |
| 异常类型 | `NovaRuntimeException` | `NovaRuntimeException` | `NovaRuntimeException` | `ScriptException` |
| 适用场景 | 快速嵌入、规则引擎 | 完全控制 | AST 缓存、自定义编译流水线 | 标准化集成、引擎可替换 |

---

## 类型转换

Java 和 Nova 之间的值自动转换：

| Java 类型 | Nova 类型 |
|-----------|-----------|
| `Integer` | `Int` |
| `Long` | `Long` |
| `Double` | `Double` |
| `Float` | `Float` |
| `Boolean` | `Boolean` |
| `String` | `String` |
| `Character` | `Char` |
| `List` | `List`（元素递归转换） |
| `Map` | `Map`（键值递归转换） |
| `null` | `null` |
| 其他对象 | `ExternalObject`（可调用其 Java 方法） |

Nova 返回值同样自动转换回对应的 Java 类型。

---

## 安全策略

嵌入式场景下通过 `NovaSecurityPolicy` 配置安全限制：

```java
import nova.runtime.interpreter.Interpreter;
import nova.runtime.interpreter.NovaSecurityPolicy;

// 预定义级别
Interpreter interp = new Interpreter(NovaSecurityPolicy.strict());
Interpreter interp = new Interpreter(NovaSecurityPolicy.standard());

// 自定义策略
NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
    .allowJavaInterop(true)
    .allowPackage("java.util")
    .allowPackage("java.math")
    .denyClass("java.lang.Runtime")
    .denyMethod("java.lang.System", "exit")
    .maxExecutionTime(5000)
    .maxRecursionDepth(128)
    .maxLoopIterations(1000000)
    .build();
Interpreter interp = new Interpreter(policy);
```

| 配置项 | 说明 | UNRESTRICTED 默认值 |
|--------|------|---------------------|
| `allowJavaInterop` | 是否允许 Java 互操作 | `true` |
| `allowSetAccessible` | 是否允许反射 setAccessible | `true` |
| `allowStdio` | 是否允许标准 I/O | `true` |
| `allowPackage(pkg)` | 添加允许的 Java 包 | 全部允许 |
| `denyPackage(pkg)` | 禁止的 Java 包 | 无 |
| `denyClass(cls)` | 禁止的 Java 类 | 无 |
| `denyMethod(cls, method)` | 禁止的 Java 方法 | 无 |
| `maxExecutionTime(ms)` | 最大执行时间（0=无限制） | `0` |
| `maxRecursionDepth(n)` | 最大递归深度（0=无限制） | `0` |
| `maxLoopIterations(n)` | 最大循环迭代次数（0=无限制） | `0` |

---

## 注册自定义函数

三种方式将 Java/Kotlin 函数注册到 Nova 中。

### 方式一：NovaNativeFunction

直接构造函数对象，适合少量函数：

```java
import nova.runtime.interpreter.*;

// 完整构造
NovaNativeFunction greet = new NovaNativeFunction("greet", 1,
    (interp, args) -> new NovaString("Hello, " + args.get(0).asString() + "!")
);

// 注册到 Interpreter
interpreter.getGlobals().defineVal("greet", greet);
interpreter.eval("println(greet(\"Nova\"))");  // Hello, Nova!

// 或注册到 ScriptEngine
engine.put("greet", greet);
engine.eval("println(greet(\"Nova\"))");  // Hello, Nova!
```

`NovaNativeFunction` 构造参数：

| 参数 | 说明 |
|------|------|
| `name` | 函数名称 |
| `arity` | 参数个数（-1 表示可变参数） |
| `function` | `(Interpreter, List<NovaValue>) -> NovaValue` |

便捷工厂方法：

```java
// 无参函数
NovaNativeFunction.create("now",
    () -> new NovaString(LocalDateTime.now().toString()));

// 单参函数
NovaNativeFunction.create("double",
    (a) -> NovaInt.of(a.asInt() * 2));

// 双参函数
NovaNativeFunction.create("add",
    (a, b) -> NovaInt.of(a.asInt() + b.asInt()));

// 三参函数
NovaNativeFunction.create("clamp",
    (v, lo, hi) -> NovaInt.of(Math.max(lo.asInt(), Math.min(hi.asInt(), v.asInt()))));

// 可变参数函数
NovaNativeFunction.createVararg("sum", (interp, args) -> {
    int total = 0;
    for (NovaValue arg : args) total += arg.asInt();
    return NovaInt.of(total);
});
```

### 方式二：@NovaFunc 注解批量注册

将一个 Java 类中的静态方法批量导出为 Nova 函数：

```java
import nova.runtime.interpreter.NovaFunc;

public class MathUtils {

    @NovaFunc("square")
    public static int square(int x) {
        return x * x;
    }

    @NovaFunc("clamp")
    public static double clamp(double value, double min, double max) {
        return Math.max(min, Math.min(max, value));
    }

    @NovaFunc("timestamp")
    public static long timestamp() {
        return System.currentTimeMillis();
    }
}
```

注册：

```java
Interpreter interpreter = new Interpreter();
interpreter.registerAll(MathUtils.class);

interpreter.eval("println(square(5))");          // 25
interpreter.eval("println(clamp(15, 0, 10))");   // 10.0
```

`@NovaFunc` 方法要求：
- 必须是 `public static`
- 参数类型支持：`int`、`long`、`double`、`float`、`boolean`、`String`、`NovaValue`
- 返回类型支持：上述类型 + `void`（返回 Unit）
- 第一个参数为 `Interpreter` 类型时，自动注入解释器实例
- 单个 `List<NovaValue>` 参数时，视为可变参数函数

```java
// 需要访问解释器的函数
@NovaFunc("evalExpr")
public static NovaValue evalExpr(Interpreter interp, String expr) {
    return interp.eval(expr);
}

// 可变参数函数
@NovaFunc("joinAll")
public static String joinAll(java.util.List<NovaValue> args) {
    StringBuilder sb = new StringBuilder();
    for (NovaValue v : args) sb.append(v.asString());
    return sb.toString();
}
```

### 方式三：直接操作 Environment

最底层的方式，可注册函数、常量、变量：

```java
Interpreter interpreter = new Interpreter();
Environment globals = interpreter.getGlobals();

// 注册函数
globals.defineVal("add", new NovaNativeFunction("add", 2,
    (interp, args) -> NovaInt.of(args.get(0).asInt() + args.get(1).asInt())
));

// 注册常量
globals.defineVal("APP_VERSION", new NovaString("1.0.0"));

// 注册可变变量
globals.defineVar("counter", NovaInt.of(0));

interpreter.eval("println(add(1, 2))");        // 3
interpreter.eval("println(APP_VERSION)");       // 1.0.0
```

---

## 完整示例

### Java — 嵌入 Nova 作为规则引擎

```java
import nova.runtime.interpreter.*;

public class RuleEngine {
    private final Interpreter interpreter;

    public RuleEngine() {
        NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
            .maxExecutionTime(1000)
            .build();
        this.interpreter = new Interpreter(policy);
    }

    public boolean evaluate(String rule, Map<String, Object> facts) {
        Environment env = interpreter.getGlobals();
        for (Map.Entry<String, Object> e : facts.entrySet()) {
            NovaValue val = NovaValue.fromJava(e.getValue());
            if (env.contains(e.getKey())) {
                env.assign(e.getKey(), val);
            } else {
                env.defineVar(e.getKey(), val);
            }
        }
        return interpreter.eval(rule).isTruthy();
    }
}

// 使用
RuleEngine engine = new RuleEngine();
Map<String, Object> facts = new HashMap<>();
facts.put("age", 20);
facts.put("score", 85);
System.out.println(engine.evaluate("age >= 18 && score > 60", facts));  // true
```

### Kotlin — 带自定义函数的脚本执行器

```kotlin
import nova.runtime.interpreter.*

class ScriptRunner {
    private val interpreter = Interpreter()

    init {
        // 注册自定义函数
        interpreter.globals.defineVal("formatDate",
            NovaNativeFunction.create("formatDate") { dateStr ->
                val formatted = dateStr.asString().replace("-", "/")
                NovaString(formatted)
            }
        )
    }

    fun run(script: String, vars: Map<String, Any> = emptyMap()): Any? {
        val env = interpreter.globals
        vars.forEach { (k, v) ->
            val nv = NovaValue.fromJava(v)
            if (env.contains(k)) env.assign(k, nv)
            else env.defineVar(k, nv)
        }
        return interpreter.eval(script).toJavaValue()
    }
}

// 使用
val runner = ScriptRunner()
val result = runner.run(
    """formatDate("2024-01-15")""",
)
println(result)  // 2024/01/15
```

### JSR-223 — 预编译批量评估

```java
import javax.script.*;

ScriptEngine engine = new ScriptEngineManager().getEngineByName("nova");
CompiledScript compiled = ((Compilable) engine).compile("price * quantity * (1 - discount)");

// 批量计算
double[][] orders = {{100, 2, 0.1}, {50, 5, 0.2}, {200, 1, 0}};
for (double[] order : orders) {
    engine.put("price", order[0]);
    engine.put("quantity", order[1]);
    engine.put("discount", order[2]);
    System.out.println(compiled.eval());
}
// 180.0
// 200.0
// 200.0
```

---

## 5. 宿主调度器集成

当 Nova 嵌入到有自己调度模型的宿主环境（如 Bukkit 基于 Tick 的调度器）时，
可通过 `NovaScheduler` SPI 让 Nova 的 `schedule` / `scheduleRepeat` / `Dispatchers.Main`
对接宿主调度器。

### NovaScheduler 接口

```java
public interface NovaScheduler {
    /** 宿主主线程执行器（同步调度器），返回 null 表示无主线程概念 */
    Executor mainExecutor();
    /** 宿主异步执行器（异步调度器），返回 null 时 scope {} 使用内置线程池 */
    default Executor asyncExecutor() { return null; }
    /** 当前线程是否为宿主主线程 */
    boolean isMainThread();
    /** 延迟后在主线程执行 */
    Cancellable scheduleLater(long delayMs, Runnable task);
    /** 重复执行 */
    Cancellable scheduleRepeat(long delayMs, long periodMs, Runnable task);

    interface Cancellable {
        void cancel();
        boolean isCancelled();
    }
}
```

### Bukkit 集成示例

**1. 实现 NovaScheduler**

```java
import nova.runtime.NovaScheduler;
import org.bukkit.Bukkit;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitTask;

public class BukkitNovaScheduler implements NovaScheduler {
    private final Plugin plugin;

    public BukkitNovaScheduler(Plugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public java.util.concurrent.Executor mainExecutor() {
        return task -> Bukkit.getScheduler().runTask(plugin, task);
    }

    @Override
    public java.util.concurrent.Executor asyncExecutor() {
        return task -> Bukkit.getScheduler().runTaskAsynchronously(plugin, task);
    }

    @Override
    public boolean isMainThread() {
        return Bukkit.isPrimaryThread();
    }

    @Override
    public Cancellable scheduleLater(long delayMs, Runnable task) {
        long ticks = Math.max(1, delayMs / 50);
        BukkitTask bt = Bukkit.getScheduler().runTaskLater(plugin, task, ticks);
        return new BukkitCancellable(bt);
    }

    @Override
    public Cancellable scheduleRepeat(long delayMs, long periodMs, Runnable task) {
        long delayTicks = Math.max(1, delayMs / 50);
        long periodTicks = Math.max(1, periodMs / 50);
        BukkitTask bt = Bukkit.getScheduler()
                .runTaskTimer(plugin, task, delayTicks, periodTicks);
        return new BukkitCancellable(bt);
    }

    private static class BukkitCancellable implements Cancellable {
        private final BukkitTask task;
        BukkitCancellable(BukkitTask task) { this.task = task; }
        @Override public void cancel() { task.cancel(); }
        @Override public boolean isCancelled() { return task.isCancelled(); }
    }
}
```

**2. 插件初始化**

```java
import nova.runtime.Nova;

public class MyPlugin extends JavaPlugin {
    private Nova nova;

    @Override
    public void onEnable() {
        nova = new Nova()
            .setScheduler(new BukkitNovaScheduler(this))
            .setStdout(System.out);

        // 加载并执行脚本
        nova.evalFile("plugins/MyPlugin/scripts/main.nova");
    }
}
```

**3. Nova 脚本 — 基础调度**

```nova
// 1 秒后在主线程发送消息
val task = schedule(1000) {
    println("1 秒后执行！")
}

// 每 5 秒重复执行
val repeating = scheduleRepeat(0, 5000) {
    println("每 5 秒执行一次")
}

// 取消任务
repeating.cancel()
```

**4. Nova 脚本 — scope / sync 简化并发**

配置 `NovaScheduler` 后，可使用 `scope` / `sync` 简化异步与主线程切换：

- **`scope { }`** — block 在异步线程执行，可使用 `delay()`
- **`sync { }`** — 切回主线程执行（Bukkit API 必须在主线程调用）

```nova
import nova.concurrent.*

// ── 场景 1：异步加载，主线程应用 ──
scope {
    val data = readFile("plugins/MyPlugin/config.json")
    val parsed = parseJson(data)
    sync {
        // Bukkit 主线程：安全操作世界
        println("配置已加载: $parsed")
    }
}

// ── 场景 2：异步延迟 ──
scope {
    delay(1000)  // 异步线程可以 delay
    sync {
        println("1 秒后在主线程执行")
    }
}

// ── 场景 3：定时任务 + 异步加载 ──
val syncTask = scheduleRepeat(0, 10000) {
    scope {
        val fresh = readFile("live-data.json")
        sync {
            println("数据已同步: $fresh")
        }
    }
}
// 插件关闭时取消
// syncTask.cancel()
```

> `scope` / `sync` 是 `coroutineScope(Dispatchers.IO)` 和 `coroutineScope(Dispatchers.Main)` 的简化写法，
> 适合大多数"异步加载 → 主线程应用"的场景。需要更细粒度的控制（如并行 async、supervisorScope 容错）时，
> 仍可使用 `coroutineScope` / `supervisorScope` + `Dispatchers`。

### 主线程安全

配置 `NovaScheduler` 后，在主线程调用 `delay()` 会抛出异常：

```
Cannot call delay() on the main thread. Use schedule(ms) { } instead.
```

这防止了主线程被 `Thread.sleep()` 阻塞（在 Bukkit 中会导致服务器卡顿）。
在需要延迟执行时，应使用 `schedule(ms) { }` 代替 `delay()`。
