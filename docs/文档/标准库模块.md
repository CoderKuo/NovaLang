# 标准库模块参考

NovaLang 提供 8 个内置标准库模块，涵盖文件 I/O、正则表达式、JSON 处理、时间日期、HTTP 客户端、测试框架、系统操作和并发编程。

## 导入方式

```nova
// 导入模块全部内容
import nova.io.*

// 导入模块中特定函数
import nova.io.readFile
import nova.io.writeFile

// 可同时导入多个模块
import nova.json.*
import nova.time.*
```

---

## nova.io

文件与目录 I/O 操作模块。所有文件操作均受安全沙箱策略控制（需 `securityPolicy.isFileAccessAllowed()` 为 `true`）。

### 函数列表

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `readFile(path: String)` | `String` | 读取文件全部内容 |
| `writeFile(path: String, content: String)` | `Unit` | 写入文件（覆盖已有内容） |
| `appendFile(path: String, content: String)` | `Unit` | 追加写入文件末尾 |
| `readLines(path: String)` | `List<String>` | 按行读取文件，返回行列表 |
| `writeLines(path: String, lines: List)` | `Unit` | 将行列表写入文件 |
| `readBytes(path: String)` | `List<Int>` | 读取文件二进制内容 |
| `writeBytes(path: String, bytes: List<Int>)` | `Unit` | 写入二进制内容 |
| `fileExists(path: String)` | `Boolean` | 检查文件是否存在 |
| `deleteFile(path: String)` | `Boolean` | 删除文件 |
| `copyFile(src: String, dst: String)` | `Unit` | 复制文件 |
| `moveFile(src: String, dst: String)` | `Unit` | 移动或重命名文件 |
| `listDir(path: String)` | `List<String>` | 列出目录中的文件和子目录 |
| `mkdir(path: String)` | `Boolean` | 创建单级目录 |
| `mkdirs(path: String)` | `Boolean` | 递归创建多级目录 |
| `isFile(path: String)` | `Boolean` | 判断路径是否为文件 |
| `isDir(path: String)` | `Boolean` | 判断路径是否为目录 |
| `fileSize(path: String)` | `Long` | 获取文件大小（字节） |
| `pathJoin(parts...)` | `String` | 拼接路径片段 |
| `fileName(path: String)` | `String` | 获取文件名部分 |
| `fileExtension(path: String)` | `String` | 获取文件扩展名 |
| `parentDir(path: String)` | `String` | 获取父目录路径 |
| `absolutePath(path: String)` | `String` | 获取绝对路径 |
| `currentDir()` | `String` | 获取当前工作目录 |
| `tempDir()` | `String` | 获取系统临时目录 |
| `tempFile(prefix: String, suffix: String)` | `String` | 创建临时文件并返回路径 |

### 示例

```nova
import nova.io.*

// 读写文本文件
writeFile("hello.txt", "Hello, NovaLang!")
val content = readFile("hello.txt")
println(content)  // Hello, NovaLang!

// 追加内容
appendFile("hello.txt", "\n第二行")

// 按行读写
val lines = readLines("hello.txt")
for (line in lines) {
    println(line)
}
writeLines("output.txt", listOf("第一行", "第二行", "第三行"))

// 文件信息查询
if (fileExists("hello.txt")) {
    println("文件大小: ${fileSize("hello.txt")} 字节")
    println("是文件: ${isFile("hello.txt")}")
    println("文件名: ${fileName("hello.txt")}")
    println("扩展名: ${fileExtension("hello.txt")}")
}

// 目录操作
mkdirs("a/b/c")
val files = listDir(".")
for (f in files) {
    println(f)
}

// 路径操作
val full = pathJoin("src", "main", "nova", "app.nova")
println(full)           // src/main/nova/app.nova
println(parentDir(full)) // src/main/nova
println(absolutePath("."))

// 临时文件
val tmp = tempFile("nova_", ".tmp")
writeFile(tmp, "临时数据")
println("临时目录: ${tempDir()}")

// 文件复制与移动
copyFile("hello.txt", "hello_backup.txt")
moveFile("hello_backup.txt", "hello_renamed.txt")
deleteFile("hello_renamed.txt")
```

---

## nova.text

正则表达式模块，提供完整的模式匹配、查找、替换和分割功能。

### 常量

| 常量 | 类型 | 说明 |
|------|------|------|
| `IGNORE_CASE` | `Int` | 忽略大小写标志 |
| `MULTILINE` | `Int` | 多行模式标志 |
| `DOT_MATCHES_ALL` | `Int` | 点号匹配所有字符（含换行符） |

### 函数

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `Regex(pattern: String, options: Int = 0)` | `RegexObject` | 编译正则表达式 |

### RegexObject 方法

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `matches(input: String)` | `Boolean` | 整个字符串是否完全匹配 |
| `containsMatchIn(input: String)` | `Boolean` | 字符串中是否包含匹配 |
| `find(input: String)` | `MatchResult?` | 查找第一个匹配，无匹配返回 null |
| `findAll(input: String)` | `List<MatchResult>` | 查找所有匹配 |
| `replace(input: String, replacement: String)` | `String` | 替换所有匹配 |
| `replaceFirst(input: String, replacement: String)` | `String` | 替换第一个匹配 |
| `split(input: String)` | `List<String>` | 按匹配位置分割字符串 |

### MatchResult 属性

| 属性 | 类型 | 说明 |
|------|------|------|
| `value` | `String` | 匹配到的字符串 |
| `start` | `Int` | 匹配起始位置 |
| `end` | `Int` | 匹配结束位置 |
| `groups` | `List` | 捕获组列表 |
| `groupValues` | `List<String>` | 捕获组值的字符串列表 |

### 示例

```nova
import nova.text.*

// 基本匹配
val emailRegex = Regex("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
println(emailRegex.matches("user@example.com"))  // true
println(emailRegex.matches("not-an-email"))       // false

// 查找匹配
val text = "联系方式: alice@nova.dev 和 bob@nova.dev"
val match = emailRegex.find(text)
if (match != null) {
    println("找到: ${match.value}")  // 找到: alice@nova.dev
    println("位置: ${match.start}-${match.end}")
}

// 查找所有匹配
val allMatches = emailRegex.findAll(text)
for (m in allMatches) {
    println(m.value)
}

// 替换
val censored = emailRegex.replace(text, "[已隐藏]")
println(censored)  // 联系方式: [已隐藏] 和 [已隐藏]

// 捕获组
val dateRegex = Regex("(\\d{4})-(\\d{2})-(\\d{2})")
val dateMatch = dateRegex.find("日期: 2026-02-17")
if (dateMatch != null) {
    val groups = dateMatch.groupValues
    println("年: ${groups[1]}, 月: ${groups[2]}, 日: ${groups[3]}")
}

// 忽略大小写
val caseInsensitive = Regex("hello", IGNORE_CASE)
println(caseInsensitive.containsMatchIn("HELLO WORLD"))  // true

// 分割字符串
val parts = Regex("[,;\\s]+").split("a, b; c  d")
println(parts)  // [a, b, c, d]

// 多行模式
val multiline = Regex("^\\w+", MULTILINE)
val lines = "first\nsecond\nthird"
val starts = multiline.findAll(lines)
for (s in starts) {
    println(s.value)  // first, second, third
}
```

---

## nova.json

JSON 序列化与反序列化模块，支持 NovaLang 数据类型与 JSON 的相互转换。

### 函数列表

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `jsonParse(text: String)` | `Any` | 解析 JSON 字符串 |
| `jsonStringify(value: Any)` | `String` | 序列化为紧凑 JSON |
| `jsonStringifyPretty(value: Any, indent: Int = 2)` | `String` | 序列化为美化格式 JSON |

### 类型映射

| JSON 类型 | NovaLang 类型 |
|-----------|--------------|
| `object` | `Map` |
| `array` | `List` |
| `string` | `String` |
| `number`（整数） | `Int` |
| `number`（小数） | `Double` |
| `boolean` | `Boolean` |
| `null` | `null` |

### 示例

```nova
import nova.json.*

// 解析 JSON 字符串
val jsonStr = """{"name": "Nova", "version": 1, "features": ["fast", "safe"]}"""
val data = jsonParse(jsonStr)
println(data["name"])       // Nova
println(data["version"])    // 1
println(data["features"])   // [fast, safe]

// 解析 JSON 数组
val arr = jsonParse("[1, 2, 3]")
println(arr[0])  // 1

// 序列化为 JSON
val config = mapOf(
    "host" to "localhost",
    "port" to 8080,
    "debug" to true,
    "tags" to listOf("web", "api")
)
println(jsonStringify(config))
// {"host":"localhost","port":8080,"debug":true,"tags":["web","api"]}

// 美化输出
println(jsonStringifyPretty(config))
// {
//   "host": "localhost",
//   "port": 8080,
//   "debug": true,
//   "tags": [
//     "web",
//     "api"
//   ]
// }

// 自定义缩进
println(jsonStringifyPretty(config, 4))

// 实际场景：读取 JSON 配置文件
import nova.io.*
val configText = readFile("config.json")
val cfg = jsonParse(configText)
println("服务器端口: ${cfg["port"]}")
```

---

## nova.time

时间与日期操作模块，提供时间戳获取、日期时间计算、格式化和时间间隔操作。

### 顶层函数

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `now()` | `Long` | 当前毫秒级时间戳（自 1970-01-01） |
| `nowNanos()` | `Long` | 纳秒精度时间戳（用于性能测量） |
| `sleep(millis: Long)` | `Unit` | 线程休眠指定毫秒 |

### DateTime 命名空间

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `DateTime.now()` | `DateTimeObj` | 获取当前日期时间 |
| `DateTime.of(year, month, day, hour, minute, second)` | `DateTimeObj` | 创建指定日期时间 |
| `DateTime.parse(str: String)` | `DateTimeObj` | 解析 ISO 8601 格式字符串 |

### DateTimeObj 属性与方法

| 成员 | 类型/返回值 | 说明 |
|------|------------|------|
| `year` | `Int` | 年 |
| `month` | `Int` | 月 |
| `day` | `Int` | 日 |
| `hour` | `Int` | 时 |
| `minute` | `Int` | 分 |
| `second` | `Int` | 秒 |
| `plusDays(n)` | `DateTimeObj` | 加 n 天 |
| `plusHours(n)` | `DateTimeObj` | 加 n 小时 |
| `plusMinutes(n)` | `DateTimeObj` | 加 n 分钟 |
| `plusSeconds(n)` | `DateTimeObj` | 加 n 秒 |
| `minusDays(n)` | `DateTimeObj` | 减 n 天 |
| `minusHours(n)` | `DateTimeObj` | 减 n 小时 |
| `minusMinutes(n)` | `DateTimeObj` | 减 n 分钟 |
| `minusSeconds(n)` | `DateTimeObj` | 减 n 秒 |
| `format(pattern: String)` | `String` | 按格式模板输出 |
| `isBefore(other)` | `Boolean` | 是否在另一时间之前 |
| `isAfter(other)` | `Boolean` | 是否在另一时间之后 |
| `durationTo(other)` | `DurationObj` | 计算到另一时间的间隔 |
| `toString()` | `String` | 输出 ISO 8601 格式 |

### Duration 命名空间

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `Duration.ofMillis(n)` | `DurationObj` | 创建毫秒时间间隔 |
| `Duration.ofSeconds(n)` | `DurationObj` | 创建秒时间间隔 |
| `Duration.ofMinutes(n)` | `DurationObj` | 创建分钟时间间隔 |
| `Duration.ofHours(n)` | `DurationObj` | 创建小时时间间隔 |
| `Duration.ofDays(n)` | `DurationObj` | 创建天时间间隔 |

### DurationObj 属性

| 属性 | 类型 | 说明 |
|------|------|------|
| `totalMillis` | `Long` | 总毫秒数 |
| `totalSeconds` | `Long` | 总秒数 |
| `days` | `Long` | 天数部分 |
| `hours` | `Long` | 小时部分 |
| `minutes` | `Long` | 分钟部分 |
| `seconds` | `Long` | 秒数部分 |

### 示例

```nova
import nova.time.*

// 时间戳
val timestamp = now()
println("当前时间戳: $timestamp")

// 性能测量
val start = nowNanos()
// ... 执行耗时操作 ...
val elapsed = nowNanos() - start
println("耗时: ${elapsed / 1000000} 毫秒")

// 创建日期时间
val dt = DateTime.of(2026, 2, 17, 14, 30, 0)
println(dt)  // 2026-02-17T14:30:00

// 获取属性
println("年: ${dt.year}, 月: ${dt.month}, 日: ${dt.day}")

// 日期计算
val tomorrow = dt.plusDays(1)
val lastWeek = dt.minusDays(7)
println("明天: ${tomorrow.format("yyyy-MM-dd")}")
println("上周: ${lastWeek.format("yyyy-MM-dd")}")

// 格式化
val current = DateTime.now()
println(current.format("yyyy年MM月dd日 HH:mm:ss"))

// 解析日期
val parsed = DateTime.parse("2026-01-01T00:00:00")
println(parsed.format("yyyy-MM-dd"))

// 日期比较
if (current.isAfter(parsed)) {
    println("当前时间晚于 2026-01-01")
}

// 时间间隔
val duration = parsed.durationTo(current)
println("间隔天数: ${duration.days}")
println("间隔总秒数: ${duration.totalSeconds}")

// Duration 构造
val oneHour = Duration.ofHours(1)
println("一小时 = ${oneHour.totalMillis} 毫秒")
println("一小时 = ${oneHour.totalSeconds} 秒")

// 休眠
println("休眠 1 秒...")
sleep(1000)
println("醒来了")
```

---

## nova.http

HTTP 客户端模块，支持常用 HTTP 方法和链式请求构建。所有网络操作受安全沙箱策略控制（需 `securityPolicy.isNetworkAllowed()` 为 `true`）。

### 快捷函数

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `httpGet(url: String)` | `HttpResponse` | 发送 GET 请求 |
| `httpPost(url: String, body: String)` | `HttpResponse` | 发送 POST 请求 |
| `httpPut(url: String, body: String)` | `HttpResponse` | 发送 PUT 请求 |
| `httpDelete(url: String)` | `HttpResponse` | 发送 DELETE 请求 |
| `HttpRequest(url: String)` | `RequestBuilder` | 创建请求构建器 |

### RequestBuilder 方法（链式调用）

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `.method(m: String)` | `RequestBuilder` | 设置 HTTP 方法 |
| `.header(name: String, value: String)` | `RequestBuilder` | 添加单个请求头 |
| `.headers(map: Map)` | `RequestBuilder` | 批量设置请求头 |
| `.body(content: String)` | `RequestBuilder` | 设置请求体 |
| `.timeout(millis: Int)` | `RequestBuilder` | 设置超时时间 |
| `.send()` | `HttpResponse` | 发送请求 |

### HttpResponse 属性与方法

| 成员 | 类型/返回值 | 说明 |
|------|------------|------|
| `statusCode` | `Int` | HTTP 状态码 |
| `body` | `String` | 响应体字符串 |
| `headers` | `Map` | 响应头 |
| `isOk` | `Boolean` | 状态码是否在 200-299 范围内 |
| `json()` | `Any` | 将响应体解析为 JSON |

### 示例

```nova
import nova.http.*

// 简单 GET 请求
val resp = httpGet("https://api.example.com/data")
if (resp.isOk) {
    println("状态码: ${resp.statusCode}")
    println("响应: ${resp.body}")
}

// 获取 JSON 数据
val apiResp = httpGet("https://api.example.com/users")
if (apiResp.isOk) {
    val users = apiResp.json()
    for (user in users) {
        println("${user["name"]} - ${user["email"]}")
    }
}

// POST 请求
import nova.json.*
val payload = jsonStringify(mapOf("name" to "Nova", "type" to "language"))
val postResp = httpPost("https://api.example.com/items", payload)
println("创建结果: ${postResp.statusCode}")

// 链式构建请求
val response = HttpRequest("https://api.example.com/data")
    .method("POST")
    .header("Content-Type", "application/json")
    .header("Authorization", "Bearer token123")
    .body(jsonStringify(mapOf("key" to "value")))
    .timeout(5000)
    .send()

println("状态: ${response.statusCode}")
println("响应头: ${response.headers}")

// 批量设置请求头
val headers = mapOf(
    "Content-Type" to "application/json",
    "Accept" to "application/json",
    "X-Custom-Header" to "nova"
)
val resp2 = HttpRequest("https://api.example.com/resource")
    .method("PUT")
    .headers(headers)
    .body("{\"updated\": true}")
    .send()

// DELETE 请求
val delResp = httpDelete("https://api.example.com/items/123")
if (delResp.isOk) {
    println("删除成功")
}
```

---

## nova.test

轻量级测试框架模块，提供测试用例定义、分组和丰富的断言函数。

### 测试组织函数

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `test(name: String, block: () -> Unit)` | `Unit` | 定义一个测试用例 |
| `testGroup(name: String, block: () -> Unit)` | `Unit` | 定义测试分组 |
| `runTests()` | `Map` | 运行所有已注册的测试，返回结果统计 |

### 断言函数

| 函数签名 | 说明 |
|----------|------|
| `assertEqual(expected, actual)` | 断言两个值相等 |
| `assertNotEqual(a, b)` | 断言两个值不相等 |
| `assertTrue(value)` | 断言值为 `true` |
| `assertFalse(value)` | 断言值为 `false` |
| `assertNull(value)` | 断言值为 `null` |
| `assertNotNull(value)` | 断言值不为 `null` |
| `assertThrows(block: () -> Unit)` | 断言代码块抛出异常 |
| `assertContains(collection, element)` | 断言集合包含指定元素 |
| `assertFails(block: () -> Unit)` | 断言代码块执行失败（`assertThrows` 的别名） |

### runTests() 返回值

返回一个 Map，包含以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `total` | `Int` | 测试总数 |
| `passed` | `Int` | 通过数 |
| `failed` | `Int` | 失败数 |
| `errors` | `List` | 错误详情列表 |

### 示例

```nova
import nova.test.*

// 定义测试用例
test("加法测试") {
    assertEqual(4, 2 + 2)
    assertEqual(0, -1 + 1)
}

test("字符串操作") {
    val s = "Hello, Nova"
    assertTrue(s.startsWith("Hello"))
    assertContains(s, "Nova")
    assertEqual(11, s.length())
}

test("空值检查") {
    val x = null
    val y = "not null"
    assertNull(x)
    assertNotNull(y)
}

test("异常断言") {
    assertThrows {
        val list = listOf(1, 2, 3)
        list[10]  // 越界异常
    }
}

// 测试分组
testGroup("数学函数") {
    test("绝对值") {
        assertEqual(5, abs(-5))
        assertEqual(0, abs(0))
    }

    test("最大值") {
        assertEqual(10, max(3, 10))
        assertEqual(-1, max(-1, -5))
    }
}

testGroup("集合操作") {
    test("列表过滤") {
        val nums = listOf(1, 2, 3, 4, 5)
        val evens = nums.filter { it % 2 == 0 }
        assertEqual(2, evens.size())
        assertContains(evens, 2)
        assertContains(evens, 4)
    }

    test("Map 操作") {
        val m = mutableMapOf("a" to 1)
        m["b"] = 2
        assertEqual(2, m.size())
        assertNotEqual(m["a"], m["b"])
    }
}

// 运行所有测试
val results = runTests()
println("总计: ${results["total"]}")
println("通过: ${results["passed"]}")
println("失败: ${results["failed"]}")

if (results["failed"] > 0) {
    println("失败详情:")
    for (err in results["errors"]) {
        println("  - $err")
    }
}
```

---

## nova.system

系统操作模块，提供环境变量访问、JVM 属性查询、外部进程执行和系统资源信息。部分操作受安全沙箱策略控制。

### 函数列表

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `env(name: String)` | `String?` | 获取环境变量，不存在返回 null |
| `envOrDefault(name: String, default: String)` | `String` | 获取环境变量，不存在返回默认值 |
| `allEnv()` | `Map<String, String>` | 获取所有环境变量 |
| `sysProperty(name: String)` | `String?` | 获取 JVM 系统属性 |
| `args()` | `List<String>` | 获取命令行参数 |
| `exec(command...)` | `Map` | 执行外部进程 |
| `exit(code: Int)` | — | 退出程序 |
| `totalMemory()` | `Long` | JVM 总分配内存（字节） |
| `freeMemory()` | `Long` | JVM 空闲内存（字节） |

### 常量

| 常量 | 类型 | 说明 |
|------|------|------|
| `osName` | `String` | 操作系统名称（如 "Windows 10"、"Linux"） |
| `jvmVersion` | `String` | JVM 版本号 |
| `novaVersion` | `String` | NovaLang 版本号（"0.1.0"） |
| `availableProcessors` | `Int` | 可用 CPU 核心数 |

### exec() 返回值

返回一个 Map，包含以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `exitCode` | `Int` | 进程退出码（0 表示成功） |
| `stdout` | `String` | 标准输出内容 |
| `stderr` | `String` | 标准错误内容 |

### 示例

```nova
import nova.system.*

// 环境变量
val home = env("HOME") ?: env("USERPROFILE")
println("用户目录: $home")

val path = envOrDefault("MY_CONFIG", "/etc/default.conf")
println("配置路径: $path")

// 系统信息
println("操作系统: $osName")
println("JVM 版本: $jvmVersion")
println("Nova 版本: $novaVersion")
println("CPU 核心数: $availableProcessors")

// JVM 属性
val javaHome = sysProperty("java.home")
println("Java 路径: $javaHome")

// 内存信息
val total = totalMemory()
val free = freeMemory()
println("总内存: ${total / 1024 / 1024} MB")
println("空闲: ${free / 1024 / 1024} MB")
println("已用: ${(total - free) / 1024 / 1024} MB")

// 命令行参数
val arguments = args()
if (arguments.size() > 0) {
    println("第一个参数: ${arguments[0]}")
}

// 执行外部命令
val result = exec("git", "status")
if (result["exitCode"] == 0) {
    println(result["stdout"])
} else {
    println("错误: ${result["stderr"]}")
}

// 执行 shell 命令
val lsResult = exec("ls", "-la")
println(lsResult["stdout"])

// 遍历所有环境变量
val allVars = allEnv()
for (entry in allVars) {
    println("${entry.key} = ${entry.value}")
}

// 退出程序
// exit(0)  // 正常退出
// exit(1)  // 异常退出
```

---

## nova.concurrent

并发编程模块，提供并行执行、原子变量、通道（Channel）和互斥锁（Mutex）等并发原语。

> **注意**：所有并发函数和类型已提升为全局内置函数，无需 `import nova.concurrent.*` 即可直接使用。`import nova.concurrent.*` 仍然合法但不再必要。

### 顶层函数

| 函数签名 | 返回值 | 说明 |
|----------|--------|------|
| `launch(block: () -> Any)` | `Job` | fire-and-forget 异步执行，返回可 await 的 Job |
| `parallel(tasks...)` | `List` | 并行执行多个 lambda，返回所有结果列表 |
| `withTimeout(millis: Long, block: () -> Any)` | `Any` | 在超时时间内执行代码块，超时抛异常 |
| `awaitAll(futures: List<Future>)` | `List` | 等待所有 Future 完成，返回结果列表 |
| `awaitFirst(futures: List<Future>)` | `Any` | 返回第一个完成的 Future 的结果 |
| `withContext(executor: Executor, block: () -> Any)` | `Any` | 在指定 Executor 上执行 block 并阻塞等待结果 |
| `delay(millis: Long)` | `Unit` | 延迟指定毫秒（主线程调用时抛异常） |
| `schedule(delayMs: Long, block: () -> Unit)` | `Task` | 延迟后通过宿主调度器执行，需先配置 `NovaScheduler` |
| `scheduleRepeat(delayMs: Long, periodMs: Long, block: () -> Unit)` | `Task` | 重复调度执行，需先配置 `NovaScheduler` |
| `scope(block: () -> Any)` | `Any` | 在异步线程执行 block，阻塞调用者直到完成。block 内可用 `delay()` |
| `sync(block: () -> Any)` | `Any` | 提交到宿主主线程执行并等待结果返回，需先配置 `NovaScheduler` |

### AtomicInt

线程安全的整数类型。

| 构造 | 说明 |
|------|------|
| `AtomicInt(initial: Int)` | 创建原子整数 |

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `get()` | `Int` | 获取当前值 |
| `set(n: Int)` | `Unit` | 设置值 |
| `incrementAndGet()` | `Int` | 自增并返回新值 |
| `decrementAndGet()` | `Int` | 自减并返回新值 |
| `addAndGet(n: Int)` | `Int` | 加 n 并返回新值 |
| `compareAndSet(expect: Int, update: Int)` | `Boolean` | CAS 操作 |
| `toString()` | `String` | 字符串表示 |

### AtomicLong

线程安全的长整数类型，方法与 `AtomicInt` 相同。

| 构造 | 说明 |
|------|------|
| `AtomicLong(initial: Long)` | 创建原子长整数 |

### AtomicRef

线程安全的引用类型。

| 构造 | 说明 |
|------|------|
| `AtomicRef(initial: Any)` | 创建原子引用 |

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `get()` | `Any` | 获取当前引用 |
| `set(value: Any)` | `Unit` | 设置引用 |
| `compareAndSet(expect: Any, update: Any)` | `Boolean` | CAS 操作 |
| `toString()` | `String` | 字符串表示 |

### Channel

线程间通信通道，支持有界和无界模式。

| 构造 | 说明 |
|------|------|
| `Channel(capacity: Int = 0)` | 创建通道（0 为同步通道） |

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `send(value)` | `Unit` | 发送值（通道满时阻塞） |
| `receive()` | `Any` | 接收值（通道空时阻塞） |
| `receiveTimeout(millis)` | `Any` | 带超时接收，超时抛异常 |
| `tryReceive()` | `Any?` | 非阻塞接收，无值返回 null |
| `size()` | `Int` | 当前通道中的元素数 |
| `isEmpty()` | `Boolean` | 通道是否为空 |
| `isClosed()` | `Boolean` | 通道是否已关闭 |
| `close()` | `Unit` | 关闭通道（不清空队列，剩余消息仍可接收） |

#### Channel 迭代

Channel 支持 `for-in` 循环遍历，迭代器在通道关闭且队列为空时终止：

```nova
val ch = Channel(10)
ch.send(1)
ch.send(2)
ch.send(3)
ch.close()

for (msg in ch) {
    println(msg)  // 1, 2, 3
}
```

### Mutex

互斥锁，用于保护临界区。

| 构造 | 说明 |
|------|------|
| `Mutex()` | 创建互斥锁 |

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `lock()` | `Unit` | 获取锁（阻塞） |
| `unlock()` | `Unit` | 释放锁 |
| `tryLock()` | `Boolean` | 尝试获取锁（非阻塞） |
| `isLocked()` | `Boolean` | 锁是否被持有 |
| `withLock(block: () -> Any)` | `Any` | 在锁保护下执行代码块 |

### Task

调度任务句柄，由 `schedule()` / `scheduleRepeat()` 返回。

| 方法 | 返回值 | 说明 |
|------|--------|------|
| `cancel()` | `Unit` | 取消调度任务 |
| `isCancelled` | `Boolean` | 任务是否已取消 |

### Dispatchers.Main

当宿主通过 `Nova.setScheduler()` 注入了 `NovaScheduler` 实现后，`Dispatchers.Main` 自动可用，
代表宿主的主线程执行器。可传入 `coroutineScope` / `supervisorScope` 使协程在主线程执行。

> **注意**：未配置调度器时，`Dispatchers` 中不包含 `Main`。

### scope / sync

简化的异步/主线程切换原语，适用于嵌入宿主环境（如 Bukkit）的场景：

- **`scope { }`** — block 在异步线程执行，调用者阻塞直到完成。block 内可使用 `delay()`
- **`sync { }`** — 将 block 提交到宿主主线程执行并等待返回。已在主线程时直接执行

```nova
import nova.concurrent.*

// 异步加载数据，然后回到主线程应用
scope {
    val data = readFile("config.json")
    delay(100)
    sync {
        // 在主线程安全操作
        println("配置已加载: $data")
    }
}
```

> **注意**：`sync` 需要先配置 `NovaScheduler`，否则抛异常。

### 示例

```nova
// 所有并发函数无需 import，直接可用

// 并行执行任务
val results = parallel(
    { 1 + 1 },
    { 2 * 3 },
    { "hello".length() }
)
println(results)  // [2, 6, 5]

// launch + awaitAll
val f1 = launch { computeA() }
val f2 = launch { computeB() }
val f3 = launch { computeC() }
val all = awaitAll([f1, f2, f3])
println(all)  // [resultA, resultB, resultC]

// awaitFirst：取最快完成的结果
val fastest = awaitFirst([f1, f2, f3])
println(fastest)

// withContext：在指定 Executor 上执行
import java.util.concurrent.Executors
val pool = Executors.newFixedThreadPool(4)
val result = withContext(pool) {
    heavyComputation()
}

// 原子计数器
val counter = AtomicInt(0)
val tasks = (1..10).map {
    { counter.incrementAndGet() }
}
parallel(*tasks)
println("计数器: ${counter.get()}")  // 10

// CAS 操作
val value = AtomicInt(100)
val success = value.compareAndSet(100, 200)
println("CAS 成功: $success, 值: ${value.get()}")  // true, 200

// AtomicRef
val ref = AtomicRef("初始值")
ref.set("新值")
println(ref.get())  // 新值

// Channel 迭代
val ch = Channel(10)
ch.send(1)
ch.send(2)
ch.send(3)
ch.close()

var sum = 0
for (msg in ch) {
    sum = sum + msg
}
println(sum)  // 6

// Channel 生产者-消费者模式
val ch2 = Channel(10)
parallel(
    {
        for (i in 1..5) {
            ch2.send(i)
        }
        ch2.close()
    },
    {
        for (v in ch2) {
            println("收到: $v")
        }
    }
)

// Channel 带超时接收
val ch3 = Channel(10)
ch3.send(42)
val v = ch3.receiveTimeout(1000)  // 1 秒内等待
println(v)  // 42

// Mutex 保护共享资源
val mutex = Mutex()
var sharedList = mutableListOf()

val workers = (1..5).map { id ->
    {
        mutex.withLock {
            sharedList.add("worker-$id")
        }
    }
}
parallel(*workers)
println("结果: $sharedList")

// 超时执行
val result2 = withTimeout(3000) {
    // 必须在 3 秒内完成
    var sum = 0
    for (i in 1..1000000) {
        sum += i
    }
    sum
}
println("结果: $result2")

// 延迟
println("开始")
delay(500)
println("500 毫秒后")

// AtomicLong 用于大数计数
val bigCounter = AtomicLong(0)
bigCounter.addAndGet(1000000000)
println("大计数: ${bigCounter.get()}")
```
