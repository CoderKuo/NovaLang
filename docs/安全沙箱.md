# NovaLang 安全沙箱

NovaLang 提供内置的安全沙箱机制，用于在不受信任的环境中安全执行脚本。通过 `NovaSecurityPolicy` 可以精确控制脚本能访问的 Java 类、方法，以及 CPU / 内存等资源消耗。

---

## 快速开始

### CLI 使用

```bash
# 默认模式（无限制）
nova script.nova

# 标准沙箱（允许安全的 Java 互操作，阻止危险操作）
nova --sandbox standard script.nova

# 严格沙箱（完全禁止 Java 互操作）
nova --sandbox strict script.nova
```

### Java 嵌入使用

```java
// 严格模式运行不受信任的脚本
Interpreter interp = new Interpreter(NovaSecurityPolicy.strict());
interp.eval(untrustedCode, "user-script.nova");

// 自定义策略
NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
    .allowJavaInterop(true)
    .allowPackage("java.util")
    .denyClass("java.lang.Runtime")
    .denyMethod("java.lang.System", "exit")
    .maxExecutionTime(5000)
    .maxRecursionDepth(100)
    .build();
Interpreter interp = new Interpreter(policy);
```

---

## 预定义安全级别

### UNRESTRICTED（默认）

无任何限制，等同于未启用沙箱。适用于执行受信任的脚本。

```java
NovaSecurityPolicy.unrestricted()
```

**特点：** 所有安全检查方法直接返回 `true`，性能开销为零。

### STANDARD

允许受限的 Java 互操作，阻止文件系统、网络、反射等危险操作。适用于需要使用 Java 标准库但不允许访问系统资源的场景。

```java
NovaSecurityPolicy.standard()
```

### STRICT

完全禁止 Java 互操作，脚本只能使用 Nova 语言自身的功能和内置函数。适用于执行完全不受信任的用户脚本。

```java
NovaSecurityPolicy.strict()
```

### 三级对比

| 配置项 | UNRESTRICTED | STANDARD | STRICT |
|--------|:-----------:|:--------:|:------:|
| Java 互操作 (`Java.type()` 等) | 允许 | 允许（受限） | 禁止 |
| `java.util.*` | 允许 | 允许 | 禁止 |
| `java.math.*` / `java.time.*` / `java.text.*` | 允许 | 允许 | 禁止 |
| `java.io.*` / `java.nio.*` / `java.net.*` | 允许 | **禁止** | 禁止 |
| `java.lang.reflect.*` | 允许 | **禁止** | 禁止 |
| `Runtime` / `ProcessBuilder` | 允许 | **禁止** | 禁止 |
| `System.exit` / `System.load` | 允许 | **禁止** | 禁止 |
| `println` / `readLine` | 允许 | 允许 | 允许 |
| `javaClass()` 函数 | 允许 | **禁止** | 禁止 |
| 执行超时 | 无限制 | 30 秒 | 10 秒 |
| 递归深度 | 无限制 | 256 层 | 128 层 |
| 循环迭代 | 无限制 | 1000 万次 | 100 万次 |

---

## 自定义策略

通过 Builder API 可以精确控制每一项安全配置。

### 基本用法

```java
NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
    .allowJavaInterop(true)          // 启用 Java 互操作
    .allowStdio(true)                // 允许 println/readLine
    .allowPackage("java.util")       // 允许 java.util 包
    .allowPackage("java.math")       // 允许 java.math 包
    .denyClass("java.lang.Runtime")  // 禁止 Runtime 类
    .denyMethod("java.lang.System", "exit")  // 禁止 System.exit
    .maxExecutionTime(5000)          // 5 秒超时
    .maxRecursionDepth(200)          // 最大递归 200 层
    .maxLoopIterations(500_000)      // 最大循环 50 万次
    .build();
```

### Builder 方法一览

#### 功能开关

| 方法 | 默认值 | 说明 |
|------|--------|------|
| `allowJavaInterop(boolean)` | `true` | 是否允许 `Java.type()` / `Java.static()` 等 Java 互操作 |
| `allowStdio(boolean)` | `true` | 是否注册 `println` / `print` / `readLine` / `input` |
| `allowSetAccessible(boolean)` | `true` | 是否允许反射越权访问（预留） |

#### 类和包控制

| 方法 | 说明 |
|------|------|
| `allowPackage(String)` | 添加包白名单，如 `"java.util"` |
| `denyPackage(String)` | 添加包黑名单，如 `"java.io"` |
| `allowClass(String)` | 添加类白名单（全限定名），如 `"java.io.Serializable"` |
| `denyClass(String)` | 添加类黑名单（全限定名），如 `"java.lang.Runtime"` |
| `denyMethod(String, String)` | 添加方法黑名单，参数为 (类名, 方法名) |

#### 资源限制

| 方法 | 说明 |
|------|------|
| `maxExecutionTime(long)` | 执行超时（毫秒），0 = 无限制 |
| `maxRecursionDepth(int)` | 最大递归深度，0 = 无限制 |
| `maxLoopIterations(long)` | 最大循环迭代总次数，0 = 无限制 |

---

## 类加载规则

当脚本通过 `Java.type()` 加载 Java 类时，安全策略按以下优先级进行检查（**deny 优先于 allow**）：

1. 类在黑名单中 → **拒绝**
2. 类在白名单中 → **允许**
3. 类所在包在黑名单中 → **拒绝**
4. 包白名单非空，且类所在包不在白名单中 → **拒绝**
5. 以上都不匹配 → **允许**

示例：

```java
NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
    .allowJavaInterop(true)
    .allowPackage("java.lang")           // 允许 java.lang 包
    .denyClass("java.lang.Runtime")      // 但禁止 Runtime
    .build();

// java.lang.String     → 允许（步骤 4，在白名单包中）
// java.lang.Runtime    → 拒绝（步骤 1，在类黑名单中）
// java.util.ArrayList  → 拒绝（步骤 4，不在白名单包中）
```

---

## 资源限制详解

### 执行超时

在 `eval()` / `evalRepl()` 调用时记录起始时间，每次循环体执行时检查是否超时。

```nova
// 以下代码在 100ms 超时策略下会被中断
var i = 0
while (true) {
    i = i + 1   // 超时后抛出异常
}
```

超时检查使用 `System.nanoTime()`，精度约 20-100ns，不会显著影响正常代码的性能。

### 递归深度

每次进入函数调用或 Lambda 执行时递增计数器，退出时递减。超过限制时抛出异常。

```nova
// 以下代码在深度限制 10 的策略下会被中断
fun infinite(n: Int): Int {
    return infinite(n + 1)   // 第 11 层时抛出异常
}
infinite(0)
```

正常的有限递归不受影响：

```nova
// fib(10) 最大递归深度约 10 层，不会触发限制
fun fib(n: Int): Int {
    if (n <= 1) return n
    return fib(n - 1) + fib(n - 2)
}
fib(10)  // = 55
```

### 循环迭代

统计整个脚本执行期间所有循环体的累计执行次数（而非单个循环）。

```nova
// 两个循环合计 200 次，在限制 100 的策略下会被中断
for (i in 1..100) { /* ... */ }    // 100 次
for (j in 1..100) { /* ... */ }    // 第 101 次时抛出异常
```

---

## 安全异常

所有安全违规都会抛出 `NovaRuntimeException`，消息格式为：

```
Security policy denied: <具体原因>
```

常见异常消息：

| 场景 | 异常消息 |
|------|---------|
| 加载被禁止的类 | `Security policy denied: Cannot access class: java.lang.Runtime` |
| 调用被禁止的方法 | `Security policy denied: Cannot call method 'clear' on java.util.ArrayList` |
| 递归超限 | `Security policy denied: Maximum recursion depth exceeded (256)` |
| 循环超限 | `Security policy denied: Maximum loop iterations exceeded (10000000)` |
| 执行超时 | `Security policy denied: Execution timeout exceeded (30000ms)` |

在 Java 嵌入场景中，可以捕获这些异常进行处理：

```java
try {
    interpreter.eval(userCode, "user-script.nova");
} catch (NovaRuntimeException e) {
    if (e.getMessage().startsWith("Security policy denied")) {
        System.err.println("脚本被安全策略阻止: " + e.getMessage());
    }
}
```

---

## 典型场景

### 在线代码编辑器

只允许纯 Nova 计算，禁止一切系统访问：

```java
NovaSecurityPolicy policy = NovaSecurityPolicy.strict();
Interpreter interp = new Interpreter(policy);
```

### 插件系统

允许插件使用 Java 集合库，但禁止文件和网络操作：

```java
NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
    .allowJavaInterop(true)
    .allowStdio(true)
    .allowPackage("java.util")
    .allowPackage("java.math")
    .allowPackage("java.lang")
    .denyClass("java.lang.Runtime")
    .denyClass("java.lang.ProcessBuilder")
    .denyClass("java.lang.Thread")
    .denyPackage("java.io")
    .denyPackage("java.nio")
    .denyPackage("java.net")
    .denyPackage("java.lang.reflect")
    .denyMethod("java.lang.System", "exit")
    .maxExecutionTime(10_000)
    .maxRecursionDepth(200)
    .maxLoopIterations(1_000_000)
    .build();
```

### 教学环境

允许基本 I/O 和简单 Java 类，严格限制资源：

```java
NovaSecurityPolicy policy = NovaSecurityPolicy.custom()
    .allowJavaInterop(true)
    .allowStdio(true)
    .allowPackage("java.util")
    .allowPackage("java.lang")
    .denyClass("java.lang.Runtime")
    .denyClass("java.lang.ProcessBuilder")
    .denyPackage("java.io")
    .denyPackage("java.net")
    .denyMethod("java.lang.System", "exit")
    .maxExecutionTime(5_000)
    .maxRecursionDepth(100)
    .maxLoopIterations(100_000)
    .build();
```

---

## 注意事项

1. **默认无限制** — 不传入策略时等同于 `UNRESTRICTED`，不会影响现有代码。

2. **`println` 始终可用** — 三个预定义级别都保留了 `println`。若需禁止，使用 `custom().allowStdio(false)`。

3. **超时精度** — 超时检查发生在循环体入口处，纯计算密集型的单次循环体可能在超时后仍执行一小段时间。

4. **循环计数是累计的** — `maxLoopIterations` 限制的是整个脚本执行期间所有循环的总迭代次数，而非单个循环。

5. **REPL 模式** — 使用 `--sandbox` 启动 REPL 时，策略在 `:reset` 后仍然保持。
